# Snapshot report for `src/non-fungible.compile.test.ts`

The actual snapshot is saved in `non-fungible.compile.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## compilation nonfungible simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{contract, contractimpl, Env, String};␊
      use stellar_macros::default_impl;␊
      use stellar_tokens::non_fungible::{Base, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible full except sequential mintable enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_access::ownable::{self as ownable, Ownable};␊
      use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
      use stellar_contract_utils::upgradeable::UpgradeableInternal;␊
      use stellar_macros::{default_impl, only_owner, Upgradeable, when_not_paused};␊
      use stellar_tokens::non_fungible::{␊
          Base, burnable::NonFungibleBurnable, consecutive::{NonFungibleConsecutive, Consecutive},␊
          NonFungibleToken␊
      };␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
              ownable::set_owner(e, &owner);␊
          }␊
      ␊
          #[when_not_paused]␊
          #[only_owner]␊
          pub fn batch_mint(e: &Env, to: Address, amount: u32, caller: Address) -> u32 {␊
              Consecutive::batch_mint(e, &to, amount)␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Consecutive;␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleConsecutive for MyNFT {}␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyNFT {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              ownable::enforce_owner_auth(e);␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          #[only_owner]␊
          fn pause(e: &Env, caller: Address) {␊
              pausable::pause(e);␊
          }␊
      ␊
          #[only_owner]␊
          fn unpause(e: &Env, caller: Address) {␊
              pausable::unpause(e);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl Ownable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{contract, contractimpl, Env, String};␊
      use stellar_macros::default_impl;␊
      use stellar_tokens::non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible consecutive

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_access::ownable::{self as ownable, Ownable};␊
      use stellar_macros::{default_impl, only_owner};␊
      use stellar_tokens::non_fungible::{␊
          Base, consecutive::{NonFungibleConsecutive, Consecutive}, NonFungibleToken␊
      };␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
              ownable::set_owner(e, &owner);␊
          }␊
      ␊
          #[only_owner]␊
          pub fn batch_mint(e: &Env, to: Address, amount: u32, caller: Address) -> u32 {␊
              Consecutive::batch_mint(e, &to, amount)␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Consecutive;␊
      ␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleConsecutive for MyNFT {}␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl Ownable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_access::ownable::{self as ownable, Ownable};␊
      use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
      use stellar_macros::{default_impl, only_owner, when_not_paused};␊
      use stellar_tokens::non_fungible::{Base, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
              ownable::set_owner(e, &owner);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          #[only_owner]␊
          fn pause(e: &Env, caller: Address) {␊
              pausable::pause(e);␊
          }␊
      ␊
          #[only_owner]␊
          fn unpause(e: &Env, caller: Address) {␊
              pausable::unpause(e);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl Ownable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible upgradeable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_access::ownable::{self as ownable, Ownable};␊
      use stellar_contract_utils::upgradeable::UpgradeableInternal;␊
      use stellar_macros::{default_impl, only_owner, Upgradeable};␊
      use stellar_tokens::non_fungible::{Base, NonFungibleToken};␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
              ownable::set_owner(e, &owner);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyNFT {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              ownable::enforce_owner_auth(e);␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl Ownable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible sequential

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{contract, contractimpl, Env, String};␊
      use stellar_macros::default_impl;␊
      use stellar_tokens::non_fungible::{Base, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_access::ownable::{self as ownable, Ownable};␊
      use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
      use stellar_macros::{default_impl, only_owner, when_not_paused};␊
      use stellar_tokens::non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
              ownable::set_owner(e, &owner);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          #[only_owner]␊
          fn pause(e: &Env, caller: Address) {␊
              pausable::pause(e);␊
          }␊
      ␊
          #[only_owner]␊
          fn unpause(e: &Env, caller: Address) {␊
              pausable::unpause(e);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl Ownable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{contract, contractimpl, Env, String};␊
      use stellar_macros::default_impl;␊
      use stellar_tokens::non_fungible::{␊
          Base, enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleToken␊
      };␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Enumerable;␊
      ␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleEnumerable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible burnable enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{contract, contractimpl, Env, String};␊
      use stellar_macros::default_impl;␊
      use stellar_tokens::non_fungible::{␊
          Base, burnable::NonFungibleBurnable, enumerable::{NonFungibleEnumerable, Enumerable},␊
          NonFungibleToken␊
      };␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Enumerable;␊
      ␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {}␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleEnumerable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation nonfungible full except consecutive

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.4.1␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_access::ownable::{self as ownable, Ownable};␊
      use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
      use stellar_contract_utils::upgradeable::UpgradeableInternal;␊
      use stellar_macros::{default_impl, only_owner, Upgradeable, when_not_paused};␊
      use stellar_tokens::non_fungible::{␊
          Base, burnable::NonFungibleBurnable, enumerable::{NonFungibleEnumerable, Enumerable},␊
          NonFungibleToken␊
      };␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              let uri = String::from_str(e, "www.mytoken.com");␊
              let name = String::from_str(e, "MyNFT");␊
              let symbol = String::from_str(e, "MNFT");␊
              Base::set_metadata(e, uri, name, symbol);␊
              ownable::set_owner(e, &owner);␊
          }␊
      ␊
          #[only_owner]␊
          #[when_not_paused]␊
          pub fn mint(e: &Env, to: Address, caller: Address) {␊
              Enumerable::sequential_mint(e, &to);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Enumerable;␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleEnumerable for MyNFT {}␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyNFT {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              ownable::enforce_owner_auth(e);␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          #[only_owner]␊
          fn pause(e: &Env, caller: Address) {␊
              pausable::pause(e);␊
          }␊
      ␊
          #[only_owner]␊
          fn unpause(e: &Env, caller: Address) {␊
              pausable::unpause(e);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl Ownable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-tokens = { workspace = true }␊
      stellar-access = { workspace = true }␊
      stellar-contract-utils = { workspace = true }␊
      stellar-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      soroban-sdk = "22.0.8"␊
      stellar-tokens = "=0.4.1"␊
      stellar-access = "=0.4.1"␊
      stellar-contract-utils = "=0.4.1"␊
      stellar-macros = "=0.4.1"␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]
