# Snapshot report for `src/fungible.test.ts`

The actual snapshot is saved in `fungible.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic fungible

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    use stellar_fungible::{self as fungible, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    `

## fungible burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    use stellar_fungible::{self as fungible, burnable::FungibleBurnable, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl FungibleBurnable for MyToken {␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            fungible::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            fungible::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    `

## fungible pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_fungible::{self as fungible, FungibleToken};␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## fungible burnable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_fungible::{self as fungible, burnable::FungibleBurnable, FungibleToken};␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl FungibleBurnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            fungible::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            fungible::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## fungible preminted

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, recipient: Address) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            fungible::mintable::mint(e, &recipient, 1000000000000000000000);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    `

## fungible premint of 0

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    use stellar_fungible::{self as fungible, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    `

## fungible mintable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
    use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl FungibleMintable for MyToken {␊
        fn mint(e: &Env, account: Address, amount: i128) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            fungible::mintable::mint(e, &account, amount);␊
        }␊
    }␊
    `

## fungible ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
    use stellar_fungible::{self as fungible, FungibleToken};␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    `

## fungible full

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_fungible::{␊
        self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
    };␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl FungibleBurnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            fungible::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            fungible::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleMintable for MyToken {␊
        #[when_not_paused]␊
        fn mint(e: &Env, account: Address, amount: i128) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            fungible::mintable::mint(e, &account, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## fungible full - complex name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_fungible::{␊
        self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
    };␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct CustomToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum CustomTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl CustomToken {␊
        pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
            fungible::metadata::set_metadata(e, 18, String::from_str(e, "Custom  $ Token"), String::from_str(e, "MTK"));␊
            fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for CustomToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            fungible::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            fungible::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            fungible::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            fungible::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            fungible::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            fungible::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            fungible::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            fungible::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl FungibleBurnable for CustomToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            fungible::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            fungible::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleMintable for CustomToken {␊
        #[when_not_paused]␊
        fn mint(e: &Env, account: Address, amount: i128) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            fungible::mintable::mint(e, &account, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for CustomToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, CustomTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, CustomTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## compilation fungible simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
      use stellar_fungible::{self as fungible, FungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, ());␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible full

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible burnable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible mintable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken};␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable full

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable burnable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]

## compilation fungible upgradable mintable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      `,
      `[workspace]␊
      resolver = "2"␊
      members = ["contracts/*"]␊
      ␊
      [workspace.package]␊
      authors = []␊
      edition = "2021"␊
      license = "Apache-2.0"␊
      version = "0.0.1"␊
      ␊
      [workspace.dependencies]␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      `,
      `# Sample Rust Contract Environment␊
      ␊
      This project demonstrates a basic Rust contract environment use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/) and a test for that contract. Make sure you have the required dependencies and keep building!␊
      ␊
      ## Go further␊
      ␊
      Continue your development journey with [Stellar CLI](https://github.com/stellar/stellar-cli).␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Rust and Stellar installation guide](https://developers.stellar.org/docs/build/smart-contracts/getting-started/setup).␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      `,
    ]
